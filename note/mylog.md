## 어떻게 구현할까

## 프로젝트에 대한 생각

핵심은 최대한 많은사람이 쉬지않고 밥을 먹어야 한다.
밥을 먹으려면 양쪽의 포크를 집어야 하므로.
밥을 먹는 그룹을 홀수그룹과 짝수그룹으로 나눠서 각 그룹별로 식사시간을 가져야 할 것 같다.
한 그룹이 밥을 먹는 동안 다른 그룹은 대기하거나 잠자기, 생각하기를 해야한다.

각 그룹별 라이프 사이클은 다음과 같다.

(필요하다면 usleep대기) -> 먹기 -> 잠자기 -> 생각하기
					  이후 이 3단계 무한루프!

참고로 전체 인원이 홀수라면 3그룹으로 나누어 져야 한다.
일단 구현의 용이함을 위해 전체인원이 짝수라고 가정하고 풀어본 다음,
홀수 케이스도 받아들이는 것으로 확장하여 구현할 계획이다.

## 전체 인원이 홀수일때...

짝수일때는 2개의 그룹이 서로 돌아가면서 자원을 차지하므로 공평하게 밥을 먹일 수 있다.

그러나 홀수일때는 3개의 그룹이 생긴다.
문제는 A->B->C그룹으로 먹으면 좋지만.
한 그룹이 식사를 마친후 정해진 순서가 아닌 다른 그룹이 식사를 시작할 수 있다.
2개의 대기중이던 그룹중 어느 그룹이 식사할지 모른다는 말이다.

현재 생각한 아이디어는 3개의 그룹별 권한을 만드는 것이다.

1. 무권한
2. 서브권한 -> 주권한을 획득할 수 있다.
3. 주권한 -> 일을 시킬 수 있다.

이렇게 각 그룹에게 3개의 권한을 순차적으로 부여함으로써
공평하게 돌아가면서 밥을 먹일 수 있을 것 같다.

=========

[완료]포크와 뮤텍스를 분리함.

포크의 초기값을 -1로 저장하고 싶음. memset류의 함수를 립엪티에서 가져와야함.
think가 언제 출력되어야 할지 모르겠다.

현재 테이블에서 한번에 한명의 철학자만 밥을 먹을 수 있다.
밥을 먹는 권한이 개인으로 한정됨.

각 포크당 뮤텍스를 만들어놓고, 해당 뮤텍스를 통해서만 해당 포크에 접근할 수 있게 만들 순 없나?
뮤텍스로 잠글 수 있는 범위를 설정하고 싶다.
현재 뮤텍스의 기능은 쓰레드의 전역변수 접근/막기 중 하나만 가능한데,
나는 특정변수(i번째 포크의 상태)만 접근시키게 하고 싶다.

쓰레드가 죽는 정확한 타이밍을 해당 쓰레드 내부에서 처리할 수 없다.
모니터링쓰레드를 만들어서 죽은 쓰레드가 발생하였는지 여부를 무한루프를 돌며 확인시키도록 하자.


# 4/13 (수)

- 모니터링쓰레드 만들기.
쓰레드가 죽으면 죽음로그는 모니터링쓰레드에서? 아님 해당 쓰레드에서?
쓰레드의 죽음을 모니터링쓰레드에서 감지하므로, 로그도 모니터링쓰레드에서 해야 옳을 것 같다.

- 그룹별로 먹는법.
한 그룹의 식사가 완료되면 다음으로 식사할 그룹을 변수에 지정한다.
이 변수의 이름을 nextgroup이라고 한다.
pthread_mutex_lock을 하기전에
```C
while
	if(nextgroup == 현재쓰레드의 그룹)
		break;
pthread_mutex_lock()
// 나중에 3개의 그룹권한으로 나눌때는 1개의 권한당 무한루프 1개로
// 권한 1개당 중첩된 루프내로 들어오는 식으로 구현하자.
```
이런식으로 lock을 시도하기전에 다음 식사를 수행할 그룹에 내가 포함되는지를 확인할때까지 멈춘다.

그러면 nextgroup의 값은 언제바뀔까?

현재 식사할 그룹내 모든 철학자들이 식사를 마쳤을 때이다.
그렇다면 한 그룹내 모든 철학자가 식사했는지를 모니터링하는 쓰레드를 또 만들어야 할까?
한 그룹의 식사완료여부를 파악하는 쓰레드를 '감독관쓰레드' 라고 하자.

먼저 이 감독관쓰레드는 철학자과제의 규칙에 위배될까?
철학자의 죽음을 감지하는 모니터링쓰레드가 규칙에 위배되지 않는다면
감독관쓰레드도 위배되지 않는다.
두 쓰레드는 모두 전체 쓰레드의 상태를 감시하고 특정 상황에 반응하기 때문이다.

밥을 먹었는지 여부는 어떻게 파악할까?
각 그룹별 식사카운트를 준비한다.
그러면 1번 그룹식사 수는 처음에 0이다.
이 숫자와 특정쓰레드의 eat_count와 비교하여, eat_count가 더 클경우!
현재 턴에 식사를 완료했다고 판단한다.

이 방법으로 그룹내 모든 쓰레드가 식사를 완료했는지알수있다.

//
8018_in_ms 138 eating
8018_in_ms 180 eating
8018_in_ms 60 eating
8018_in_ms 72 eating
8018_in_ms 92 eating
EXIT DETECTED!!
10017_in_ms 80 sleeping
//
EXIT이 나오고 바로 종료시켜야함.
단 exit함수를 사용할 수 없으므로 메인함수의 return 0바로 앞에 EXIT 문자열을 출력해야겠다.
그렇게 해도 해결이 안될 것 같긴한데...
흠

그리고 홀수일때 계속해서 철학자가 죽는 문제를 해결해야 한다.

그리고 현재 단위가 ms랑 s랑 혼용되고 있어서 단위를 통합해야 한다.

# 4/17(일)

- 현재 철학자의 l,r 구분없이 저장하고 있다! 주의할 것.

개선해야 할점

- [처리완료]ms로 통일되어 있지 않다.
	=> 시간함수가 us을 반환하고 시간함수 호출부에서 /1000 하여 ms로 바꾸게 했음.
- [처리완료]한번에 프린트가 너무 많이 나온다
	#### 그냥 기존에 초단위로 진행을 해서 그런거였다..ㅎ
	-> [선택]출력뮤텍스를 줘서 한 쓰레드만 프린트할 수 있게 바꿔볼까?
	-> 각 철학자쓰레드당 출력을 담당하는 자식쓰레드를 init하고 detach할까?
- 타임스탬프가 꼬인다.
	-> 쓰레드는 먼저 수행된다고 하더라도 순서를 보장할 수 없기때문이다.
		어떻게 하면 좋을까
	1. 출력구간을 critical section으로 만들고 그 안에서 현재 시간을 측정하고 출력한다.
		이 방법은 시간측정+출력하는 시간만큼 다른 쓰레드들이 block되므로 시간측정+출력하는 시간이 매우 적어야 가능한 방법이다.
		그렇지만 타임스탬프 순서대로 출력될 수 밖에 없다.


- 전역변수로 선언한 것을 파라미터로 잘 넘겨볼것
- 구조체를 체계적으로 정리할 것.


궁금한점

- lock을 하고 그 함수가 return되면 어떻게 됨? 함수 밖에서 unlock해줘야 함?
-> 모니터 쓰레드에서 종료조건일때 출력뮤텍스를 lock하고 돌려주지 않은 상태로 return해버리면
	자동으로 unlock이 되는 것 같다.

- 모니터 쓰레드에서 unlock을 하지 않고 return을 하니 모든쓰레드들이 출력뮤텍스를 기다린다...,...왜?
=> critical section은 함수 안팍으로 설정할 수 있지만 쓰레드 안팍으로는 불가능하다.

- 출력되는 타임스탬프의 시간순 출력을 위해 출력mutex안에서 시간을 재고 출력한다.
 그러나 이에 따라 wait되는 시간이 모여서 수명 시간을 잡아먹어서 철학자가 죽어버린다.
 원인은 wait시간이 많아서!


 ./philosophers 19 610 200 200
 수행시 종료출력문이 안뜨고 그냥 종료됨... 왜????
 그리고 심지어 죽기도함...;;;


# 4/18(월) 21:37

문제 해결완료. 이제 코드 가다듬고 제출준비해야함.

정리해야 할것.

- 실행인자검사
- 전역변수 -> 메인함수의 지역변수로 변경
- 구조체 변수 용도별로 정리.
