## 어떻게 구현할까

## 프로젝트에 대한 생각

핵심은 최대한 많은사람이 쉬지않고 밥을 먹어야 한다.
밥을 먹으려면 양쪽의 포크를 집어야 하므로.
밥을 먹는 그룹을 홀수그룹과 짝수그룹으로 나눠서 각 그룹별로 식사시간을 가져야 할 것 같다.
한 그룹이 밥을 먹는 동안 다른 그룹은 대기하거나 잠자기, 생각하기를 해야한다.

각 그룹별 라이프 사이클은 다음과 같다.

(필요하다면 usleep대기) -> 먹기 -> 잠자기 -> 생각하기
					  이후 이 3단계 무한루프!

참고로 전체 인원이 홀수라면 3그룹으로 나누어 져야 한다.
일단 구현의 용이함을 위해 전체인원이 짝수라고 가정하고 풀어본 다음,
홀수 케이스도 받아들이는 것으로 확장하여 구현할 계획이다.

## 전체 인원이 홀수일때...

짝수일때는 2개의 그룹이 서로 돌아가면서 자원을 차지하므로 공평하게 밥을 먹일 수 있다.

그러나 홀수일때는 3개의 그룹이 생긴다.
문제는 A->B->C그룹으로 먹으면 좋지만.
한 그룹이 식사를 마친후 정해진 순서가 아닌 다른 그룹이 식사를 시작할 수 있다.
2개의 대기중이던 그룹중 어느 그룹이 식사할지 모른다는 말이다.

현재 생각한 아이디어는 3개의 그룹별 권한을 만드는 것이다.

1. 무권한
2. 서브권한 -> 주권한을 획득할 수 있다.
3. 주권한 -> 일을 시킬 수 있다.

이렇게 각 그룹에게 3개의 권한을 순차적으로 부여함으로써
공평하게 돌아가면서 밥을 먹일 수 있을 것 같다.

=========

[완료]포크와 뮤텍스를 분리함.

포크의 초기값을 -1로 저장하고 싶음. memset류의 함수를 립엪티에서 가져와야함.
think가 언제 출력되어야 할지 모르겠다.

현재 테이블에서 한번에 한명의 철학자만 밥을 먹을 수 있다.
밥을 먹는 권한이 개인으로 한정됨.

각 포크당 뮤텍스를 만들어놓고, 해당 뮤텍스를 통해서만 해당 포크에 접근할 수 있게 만들 순 없나?
뮤텍스로 잠글 수 있는 범위를 설정하고 싶다.
현재 뮤텍스의 기능은 쓰레드의 전역변수 접근/막기 중 하나만 가능한데,
나는 특정변수(i번째 포크의 상태)만 접근시키게 하고 싶다.

쓰레드가 죽는 정확한 타이밍을 해당 쓰레드 내부에서 처리할 수 없다.
모니터링쓰레드를 만들어서 죽은 쓰레드가 발생하였는지 여부를 무한루프를 돌며 확인시키도록 하자.


# 4/13 (수)

- 모니터링쓰레드 만들기.
쓰레드가 죽으면 죽음로그는 모니터링쓰레드에서? 아님 해당 쓰레드에서?
쓰레드의 죽음을 모니터링쓰레드에서 감지하므로, 로그도 모니터링쓰레드에서 해야 옳을 것 같다.

- 그룹별로 먹는법.
한 그룹의 식사가 완료되면 다음으로 식사할 그룹을 변수에 지정한다.
이 변수의 이름을 nextgroup이라고 한다.
pthread_mutex_lock을 하기전에
```C
while
	if(nextgroup == 현재쓰레드의 그룹)
		break;
pthread_mutex_lock()
// 나중에 3개의 그룹권한으로 나눌때는 1개의 권한당 무한루프 1개로
// 권한 1개당 중첩된 루프내로 들어오는 식으로 구현하자.
```
이런식으로 lock을 시도하기전에 다음 식사를 수행할 그룹에 내가 포함되는지를 확인할때까지 멈춘다.

그러면 nextgroup의 값은 언제바뀔까?

현재 식사할 그룹내 모든 철학자들이 식사를 마쳤을 때이다.
그렇다면 한 그룹내 모든 철학자가 식사했는지를 모니터링하는 쓰레드를 또 만들어야 할까?
한 그룹의 식사완료여부를 파악하는 쓰레드를 '감독관쓰레드' 라고 하자.

먼저 이 감독관쓰레드는 철학자과제의 규칙에 위배될까?
철학자의 죽음을 감지하는 모니터링쓰레드가 규칙에 위배되지 않는다면
감독관쓰레드도 위배되지 않는다.
두 쓰레드는 모두 전체 쓰레드의 상태를 감시하고 특정 상황에 반응하기 때문이다.

밥을 먹었는지 여부는 어떻게 파악할까?
각 그룹별 식사카운트를 준비한다.
그러면 1번 그룹식사 수는 처음에 0이다.
이 숫자와 특정쓰레드의 eat_count와 비교하여, eat_count가 더 클경우!
현재 턴에 식사를 완료했다고 판단한다.

이 방법으로 그룹내 모든 쓰레드가 식사를 완료했는지알수있다.

//
8018_in_ms 138 eating
8018_in_ms 180 eating
8018_in_ms 60 eating
8018_in_ms 72 eating
8018_in_ms 92 eating
EXIT DETECTED!!
10017_in_ms 80 sleeping
//
EXIT이 나오고 바로 종료시켜야함.
단 exit함수를 사용할 수 없으므로 메인함수의 return 0바로 앞에 EXIT 문자열을 출력해야겠다.
그렇게 해도 해결이 안될 것 같긴한데...
흠

그리고 홀수일때 계속해서 철학자가 죽는 문제를 해결해야 한다.

그리고 현재 단위가 ms랑 s랑 혼용되고 있어서 단위를 통합해야 한다.

# 4/17(일)

- 현재 철학자의 l,r 구분없이 저장하고 있다! 주의할 것.

개선해야 할점

- [처리완료]ms로 통일되어 있지 않다.
	=> 시간함수가 us을 반환하고 시간함수 호출부에서 /1000 하여 ms로 바꾸게 했음.
- [처리완료]한번에 프린트가 너무 많이 나온다
	#### 그냥 기존에 초단위로 진행을 해서 그런거였다..ㅎ
	-> [선택]출력뮤텍스를 줘서 한 쓰레드만 프린트할 수 있게 바꿔볼까?
	-> 각 철학자쓰레드당 출력을 담당하는 자식쓰레드를 init하고 detach할까?
- 타임스탬프가 꼬인다.
	-> 쓰레드는 먼저 수행된다고 하더라도 순서를 보장할 수 없기때문이다.
		어떻게 하면 좋을까
	1. 출력구간을 critical section으로 만들고 그 안에서 현재 시간을 측정하고 출력한다.
		이 방법은 시간측정+출력하는 시간만큼 다른 쓰레드들이 block되므로 시간측정+출력하는 시간이 매우 적어야 가능한 방법이다.
		그렇지만 타임스탬프 순서대로 출력될 수 밖에 없다.


- 전역변수로 선언한 것을 파라미터로 잘 넘겨볼것
- 구조체를 체계적으로 정리할 것.


궁금한점

- lock을 하고 그 함수가 return되면 어떻게 됨? 함수 밖에서 unlock해줘야 함?
-> 모니터 쓰레드에서 종료조건일때 출력뮤텍스를 lock하고 돌려주지 않은 상태로 return해버리면
	자동으로 unlock이 되는 것 같다.

- 모니터 쓰레드에서 unlock을 하지 않고 return을 하니 모든쓰레드들이 출력뮤텍스를 기다린다...,...왜?
=> critical section은 함수 안팍으로 설정할 수 있지만 쓰레드 안팍으로는 불가능하다.

- 출력되는 타임스탬프의 시간순 출력을 위해 출력mutex안에서 시간을 재고 출력한다.
 그러나 이에 따라 wait되는 시간이 모여서 수명 시간을 잡아먹어서 철학자가 죽어버린다.
 원인은 wait시간이 많아서!


 ./philosophers 19 610 200 200
 수행시 종료출력문이 안뜨고 그냥 종료됨... 왜????
 그리고 심지어 죽기도함...;;;


# 4/18(월) 21:37

문제 해결완료. 이제 코드 가다듬고 제출준비해야함.

정리해야 할것.

- 실행인자검사
- 전역변수 -> 메인함수의 지역변수로 변경
- 구조체 변수 용도별로 정리.

# 4/16(화)

필로소퍼 보너스 없이 제출했으나 실행인자 하나를 잘못 해석하여 fail받음!
(최소 식사횟수는 모든 철학자가 만족해야하지 어느누구하나라도 만족해야 하는 조건이 아니었음)

# 4/21(목) 09:14

어제 평가포인트 벌던중 필로소퍼가 잡혔는데, 보너스 구현이 생각보다 간단해보여서 세마포어로 구현중!

프로그램을 종료할때..

- 자식 프로세스를 kill해야 한다.
왜냐면 쓰레드는 메인쓰레드 종료시 자식쓰레드가 알아서 죽지만, 프로세스는 좀비프로세스가 되어 살아있음.
아... 좀비가 아니라 고아프로세스인가?

쓰레드간 정보교환을 프로세스간 정보교환으로 바뀌면서
모니터링쓰레드의 방식이 바뀌게 된다.
누가 죽었는지, 누가 식사횟수를 모두 채웠는지를 체크하는 방법으로 세마포를 사용하자.


- 어떻게 철학자의 죽음을 전달할까?

죽음 세마포어를 철학자수만큼 생성하고 각 철학자가 쥐고있는다.
메인프로세스에서 죽음 세마포어를 wait하고, 죽음 세마포어를 획득하면 누군가가 죽었다는 것을 알 수 있음.
같은 방식으로 full 세마포어도 구현 가능하다.

# 4/22(금) 11:06

- 프로세스가 예상치 못한 곳에서 죽는다. 왜 죽는지 모르겠당
	각 철학자프로세스의 모니터쓰레드가 값을 잘못 받아오고 있는 것 같다. p->idx를 출력했는데 921715136이 나왔다.
	아.... 이유를 알겠다.
	쓰레드와 함께 보내는 데이터를 pinfo라고 하는데 pinfo를 안보내고 &pinfo를 보냈다...ㅠㅠ

- 구조적인 문제점 발견
	원래 종료하는 조건이 철학자의 죽음/ 모든철학자의 식사횟수충족 2 가지 였는데
	세마포어로 이를 구현하면 한번에 한 세마포어만 wait할 수 있어서 프로세스의 종료상태를 이용하기로 했다.
	철학자가 죽으면 exit(1), 식사횟수를 충족하면 exit(0)으로 종료상태를 반환하고
	부모 프로세스에서 이를 수거하여 exit(1)이 한번이라도 나오면 철학자의 죽음으로 프로그램종료.
	모든 철학자수만큼 wait을 반복하면 된다고 생각했는데,
	부모프로세스에서 다음 wait을 하기 전에 자식프로세스가 exit을 해버리면 어긋나버린다..
	다시 세마포어로 구현을 해보아야...ㅠㅠ


# 현재 문제점

1. sem_close하면 무한 블로킹상태...

2. 모든 철학자가 다 식사횟수를 안채웠는데 종료가...? 왜지?

- 철학자 모니터쓰레드에서 무한루프를 돌면서 세마포를 한개만 놓아야 되는데

철학자 프로세스
	철학자 쓰레드
		식사로그를 찍는다
		gsleep한다
		먹은 횟수를 1 올린다.
		마지막 식사시간을 갱신한다.

	모니터 쓰레드
		full 세마포를 쥐고있는다
		무한루프
			미생존시 exit
			추가인자가 존재하고, 식사횟수를 충족했다면 full세마포 놓기

# 코드 정리 및 피드백

- 자식프로세스 kill하는 philo_exit에서..
	특정 프로세스가 죽어서 프로그램이 종료되는 상황에서
	이미 죽은 프로세스에 또 시그널을 보내는 것이 괜찮은가?
	자식프로세스가 밥못먹어서 프로세스가 종료되었고 그사이에
	다른 프로세스가 그 pid를 부여받아 돌고있다고 가정하면....
	엉뚱한 프로세스를 죽이게 될 수도 있다!!
	=> 자식프로세스가 밥못먹어서 죽었을때
	data에서 해당 프로세스의 pid를 invalid하게 만들자.

- 세마포어를 건다고 공유자원에 동기화가 되는 게 맞나...?
	thread_eat에서 d->last_eat에 접근하고
	철학자 모니터링쓰레드에서 d->last_eat에 동시접근하는데
	흠..

